### Ⅰ、数组

##### 一、数组的声明

1. 增加标识符`LMIDPAREN`和`RMIDPAREN`分别表示'['和']'，在符号表中增加可以表示数组的条目结构，由于条目的大小被结构体`comtab`限制，故如下完成数组条目的设置。

   ```c
   //记录数组属性
   typedef struct array_attribute
   {
   	short address;//数组的基址
   	int size;//数组大小
   	int dim;//总维数 
   	int dim_size[MAX_DIM + 1];//每一维的范围大小
   } array_attribute;
   //数组信息表
   array_attribute array_table[TXMAX];
   ```

2. 在`void enter()`函数中增加向符号表内添加数组变量表项，并进行部分初始化工作的内容。

   ```c
   void enter(int kind)
   {
       ...
       switch(kind){
       ...
       case ID_ARRAY:
           mk = (mask*) &table[tx];
           mk->level = level;
           mk->address = arr_tx;//表项地址为在数组信息表中的索引
           Last_Array = &(array_table[arr_tx]);//记录最后获取到的数组
           array_table[arr_tx].dim = 0; //初始化
           array_table[arr_tx].size = 1; 
           array_table[arr_tx].dim_size[1] = 0; 
           arr_tx++;
           break;
       ...
       }
   }
   ```

3. 在void varclaration()函数中增加可以识别数组的声明的内容。

   ```c
   void vardeclaration(void)
   {
   	if (sym == SYM_IDENTIFIER)
   	{
   		getsym();
   		if (sym == SYM_LMIDPAREN) {
   			enter(ID_ARRAY);
   			dimdeclaration();//数组维度相关信息的声明
   		}
   		else
   		{
   			enter(ID_VARIABLE); 
   		}
   	}
   	else
   	{
   		error(4); // There must be an identifier to follow 'const', 'var', or 'procedure'.
   	}
   } // vardeclaration
   ```

   

##### 二、数组的访问

1. 为计算数组变量的基址以及访问数组元素，增加`LEA`、`LDA`、`STA`三条指令。

   ​	`LEA`指令形式为`LEA l a`，功能为计算由`l`和`a`指示的变量的地址偏移，并放置在栈顶。其在`interpret()`函数内的代码如下。

   ```c
   case LEA:
       stack[++top] = base(stack, b, i.l) + i.a;
       break;
   ```

   ​	`LDA`指令的形式为`LDA 0 0`，功能为以栈顶内容为地址偏移，将对应位置的值加载到栈顶替换原来的栈顶。其在`interpret()`函数内的代码如下。

   ```c
   case LDA:
       stack[top] = stack[stack[top]];
       break;
   ```

   ​	`STA`指令的形式为`STA 0 0`，功能为以次栈顶内容为地址偏移，将栈顶的值存入到次栈顶指示的单元，并将栈顶和次栈顶出栈。其在`interpret()`函数内的代码如下。

   ```c
   case STA:
   	stack[stack[top-1]] = stack[top];
       top = top -2;
       break;
   ```


2. 访问数组，在遇到数组的声明或进行数组元素的赋值时，需要确定数组的大小，维度等相关信息，以及要计算出数组元素的偏移量，故增加一个数组访问函数`void array_access()`，其功能是根据数组变量各维上的数值，计算对应数组元素的偏移量，并生成相应的中间代码。

   ```c
   void array_access(short arr_index, int dim, symset fsys) {//dim代表正在分析的维度
   	getsym();
   	if (sym == SYM_LMIDPAREN) {
   		gen(LIT, 0, array_table[arr_index].dim_size[dim + 1]);
   		gen(OPR, 0, OPR_MUL);//将栈顶和次栈顶数值相乘，例如对应a[10][10]，a[3][4]，在读到3时，执行的中间代码依次为0*10=0，0+3=3,3*10=30,30+4=34.
   		getsym();
   		expression(fsys);
   		//expression中已经获取了下一个标识
   		gen(OPR, 0, OPR_ADD);//加上最外维上的偏移
   		array_access(arr_index, dim + 1, fsys);//访问下一维
   	}
   	else if (dim != array_table[arr_index].dim) { error(30); }//维度分析错误
   }
   ```

3. 增加`void dimdeclaration()`函数来分析数组的维度相关信息，包括数组大小、总维数、各维度上的范围大小。

   ```c
   void dimdeclaration() {
   	int i;
   	if (sym == SYM_LMIDPAREN) {
   		getsym();
   		switch (sym)
   		{
   		case SYM_NUMBER:
   			if (Last_Array->dim == MAX_DIM) { error(33); }//维数过多
   			Last_Array->dim = Last_Array->dim + 1;//总维数+1
   			Last_Array->dim_size[Last_Array->dim] = num;
   			Last_Array->size = Last_Array->size * num;//数组大小*最外维范围大小
   			getsym();
   			if (sym == SYM_RMIDPAREN) //继续分析下一维
   			{ 
   				getsym();
   				dimdeclaration(); 
   			}
   			else { error(27); }//missing 
   			break;
   		default:
   			error(29);//缺少维度大小
   		}
   	}
   	else {
   			dx += Last_Array->size;//为数组分配空间
   			Last_Array->address = dx - 1;//记录最后访问到的数组的基址		
   	}
   }
   ```

##### 三、数组元素的赋值

1. 为使数组变量可以在表达式右值中出现，对`void factor()`函数进行扩展，使其可以将数组元素作为表达式的因子。

   ```c
   void factor(symset fsys)
   {
       ...
       switch (table[i].kind)
   		{
               ...
   			case ID_ARRAY: //将数组元素作为表达式因子，此部分与
                   mk = (mask*)&table[i];
                   arr_index = mk->address;
                   gen(LEA, level - mk->level, array_table[arr_index].address);//把数组的基址放在栈顶
                   gen(LIT, 0, 0);//
                   set = createset(SYM_RMIDPAREN);
                   array_access(arr_index, 0, set);//获取数组元素的偏移量
                   gen(OPR, 0, OPR_MIN);//数组基址 - 偏移量=元素地址
                   gen(LDA, 0, 0);//将数组元素的值置于栈顶 
                   break;  
               ...
       	}
     	...
   }
   ```

2. 对数组元素进行赋值，对`void statement()`函数进行扩展，使其可以将数组元素作为表达式的左值。

   ```c
   void statement(symset fsys){
       ...
   	if (sym == SYM_IDENTIFIER)
   	{ 
   		...
   		else if (table[i].kind == ID_ARRAY) {//数组元素的赋值
   			mk = (mask*)&table[i];
   			arr_index = mk->address;
   			gen(LEA, level - mk->level, array_table[arr_index].address);
   			gen(LIT, 0, 0);
   			set1 = createset(SYM_RMIDPAREN);
   			array_access(arr_index, 0, set1);//访问数组元素
   			//array_access 已经获取下一个标识符
   			if (sym != SYM_BECOMES) { error(13); }
   			gen(OPR, 0, OPR_MIN);
   			getsym();
   			expression(fsys);//计算右值 
   			if (i) {
   				gen(STA, 0, 0);//将栈顶的值存入数组元素的地址(次栈顶)中
   			}
   		}
       ...
   	}
       ...
   }
   ```





### Ⅱ、Print

1. 首先，增加保留字`print`，并设置对应标识符`SYM_PRT`，对应的，在`char *word，int wsym`中添加相应的元素。

2. 增加新的指令`PRT`，格式为 `PRT 0 a`，功能为逆序打印栈顶的a个单元的内容，并从栈中弹出这些内容。在语法分析时，将每个参数的值加载到栈顶，最后生成`PRT`指令，就可以将参数的值按顺序打印。`interpret()`函数内对应的情况如下：

   ```c
   case PRT:
   	if(i.a==0){printf("\n");}
   	else{
   		for(int k=i.a-1;k>=0;k--){
   			printf("%d ",stack[top-k]);
   		}
   		top = top - i.a;
   	}
       break;
   ```

3. 在`void statement()`中增加识别`print`语句的情况。

   ```c
   void statement(void){
       ...
   	else if(sym==SYM_PRT)//表示进入打印
   	{
   		//print statement
   		getsym();
   		if (sym != SYM_LPAREN) { error(31); }// wrong in print
   		while (1) {
   			getsym();
   			if (sym == SYM_RPAREN) { break; }
   			else if (sym == SYM_IDENTIFIER) {
   				count++;
   				if ((i = position(id)) == 0) { error(11); }// Undeclared identifier.
   				else if (table[i].kind != ID_VARIABLE && table[i].kind != ID_ARRAY && 									table[i].kind != ID_CONSTANT)
   				{
   					error(31);// wrong in print
   				}
   				else {
   					if (table[i].kind == ID_VARIABLE) {
   						mask* mk;
   						mk = (mask*)&table[i];
   						gen(LOD, level - mk->level, mk->address);//变量值置于栈顶
   						getsym();
   					}
   					else if (table[i].kind == ID_CONSTANT) {
   						gen(LIT, 0, table[i].value);//常量值置于栈顶
   						getsym();
   					}
   					else if (table[i].kind == ID_ARRAY) {//数组元素值置于栈顶
   						int arr_index;
   						mask* mk;
   						mk = (mask*)&table[i];
   						arr_index = mk->address;
   						gen(LEA, level - mk->level, array_table[arr_index].address);
   						gen(LIT, 0, 0); 
   						set1 = createset(SYM_RMIDPAREN);
   						array_access(arr_index, 0, set1);
   						gen(OPR, 0, OPR_MIN);
   						gen(LDA, 0, 0);//获取数组元素值并置于栈顶 
   					}
   					if (sym == SYM_COMMA) { ; }
   					else if (sym == SYM_RPAREN) { break; }
   					else { error(28); }//wrong format
   				}
   			}
   			else if (sym==SYM_NUMBER)//数字直接置于栈顶
   			{
   				gen(LIT,0,num);
   				count++;
   				getsym();
   			}
   			else {
   				error(31);//wrong in print
   			}
   		}
   		gen(PRT, 0, count); // 打印栈顶count个值
   		getsym();
   	}
       ...
   }
   ```

   

